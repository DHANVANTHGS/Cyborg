"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// package.json
var require_package = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "cyborgdb",
      version: "0.14.0",
      description: "JavaScript & TypeScript Client SDK for CyborgDB: The Confidential Vector Database",
      main: "dist/index.js",
      module: "dist/index.esm.js",
      types: "dist/index.d.ts",
      browser: {
        "./dist/index.js": "./dist/index.esm.js"
      },
      files: [
        "dist/**/*",
        "README.md",
        "LICENSE"
      ],
      sideEffects: false,
      scripts: {
        build: "npm run clean && npm run build:cjs && npm run build:esm && npm run build:types",
        "build:cjs": "esbuild src/index.ts --bundle --platform=node --format=cjs --outfile=dist/index.js --external:fs --external:path --external:crypto --external:http --external:https --external:url --external:stream --external:querystring --external:@langchain/core",
        "build:esm": "esbuild src/index.ts --bundle --platform=node --format=esm --outfile=dist/index.esm.js --external:fs --external:path --external:crypto --external:http --external:https --external:url --external:stream --external:querystring --external:@langchain/core",
        "build:types": "tsc --emitDeclarationOnly --outDir dist",
        clean: "rm -rf dist",
        lint: "eslint 'src/*.ts' 'src/__tests__/**/*.ts'",
        "lint:fix": "eslint 'src/*.ts' 'src/__tests__/**/*.ts' --fix",
        package: "npm run lint && npm run test && npm run build && npm pack",
        prepublishOnly: "npm run lint && npm run build",
        "test:ssl": "jest __tests__/ssl-verification.test.ts",
        "test:integration": "jest __tests__/integration.test.ts",
        "test:quickflow": "jest __tests__/quick_flow.test.ts",
        "test:quickflow:built": "npm run build && jest __tests__/quick_flow.test.ts",
        test: "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/cyborginc/cyborgdb-js.git"
      },
      keywords: [
        "cyborgdb",
        "vector-database",
        "confidential",
        "typescript",
        "javascript",
        "sdk"
      ],
      author: "Cyborg Inc.",
      license: "MIT",
      bugs: {
        url: "https://github.com/cyborginc/cyborgdb-js/issues"
      },
      homepage: "https://github.com/cyborginc/cyborgdb-js#readme",
      devDependencies: {
        "@langchain/core": "^0.3.78",
        "@types/jest": "^29.5.14",
        "@types/node": "^22.13.10",
        "@typescript-eslint/eslint-plugin": "^6.21.0",
        "@typescript-eslint/parser": "^6.21.0",
        axios: "^1.12.2",
        dotenv: "^16.4.7",
        esbuild: "^0.25.8",
        eslint: "^8.57.1",
        jest: "^29.7.0",
        "ts-jest": "^29.1.2",
        "ts-node": "^10.9.2",
        typescript: "^5.8.2"
      },
      engines: {
        node: ">=18.0.0"
      }
    };
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Client: () => CyborgDB,
  CyborgVectorStore: () => CyborgVectorStore,
  EncryptedIndex: () => EncryptedIndex,
  VERSION: () => VERSION,
  getDemoApiKey: () => getDemoApiKey,
  getErrorMessage: () => getErrorMessage,
  isError: () => isError,
  isJsonValue: () => isJsonValue
});
module.exports = __toCommonJS(index_exports);

// src/runtime.ts
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = await middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            }) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  static {
    this.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  async request(context, initOverrides) {
    const { url, init } = await this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response && (response.status >= 200 && response.status < 300)) {
      return response;
    }
    throw new ResponseError(response, "Response returned an error code");
  }
  async createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
    const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async () => initOverrides;
    const initParams = {
      method: context.method,
      headers,
      body: context.body,
      credentials: this.configuration.credentials
    };
    const overriddenInit = {
      ...initParams,
      ...await initOverrideFn({
        init: initParams,
        context
      })
    };
    let body;
    if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
      body = overriddenInit.body;
    } else if (this.isJsonMime(headers["Content-Type"])) {
      body = JSON.stringify(overriddenInit.body);
    } else {
      body = overriddenInit.body;
    }
    const init = {
      ...overriddenInit,
      body
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};

// src/models/Contents.ts
function ContentsToJSON(json) {
  return ContentsToJSONTyped(json, false);
}
function ContentsToJSONTyped(value, ignoreDiscriminator = false) {
  return value;
}

// src/models/IndexConfig.ts
function IndexConfigToJSON(json) {
  return IndexConfigToJSONTyped(json, false);
}
function IndexConfigToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "dimension": value["dimension"],
    "type": value["type"],
    "pq_dim": value["pqDim"],
    "pq_bits": value["pqBits"]
  };
}

// src/models/CreateIndexRequest.ts
function CreateIndexRequestToJSON(json) {
  return CreateIndexRequestToJSONTyped(json, false);
}
function CreateIndexRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_config": IndexConfigToJSON(value["indexConfig"]),
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "embedding_model": value["embeddingModel"],
    "metric": value["metric"]
  };
}

// src/models/CyborgdbServiceApiSchemasIndexSuccessResponseModel.ts
function CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(json) {
  return CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSONTyped(json, false);
}
function CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "status": json["status"] == null ? void 0 : json["status"],
    "message": json["message"]
  };
}

// src/models/CyborgdbServiceApiSchemasVectorsSuccessResponseModel.ts
function CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(json) {
  return CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSONTyped(json, false);
}
function CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "status": json["status"] == null ? void 0 : json["status"],
    "message": json["message"]
  };
}

// src/models/DeleteRequest.ts
function DeleteRequestToJSON(json) {
  return DeleteRequestToJSONTyped(json, false);
}
function DeleteRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "ids": value["ids"]
  };
}

// src/models/GetRequest.ts
function GetRequestToJSON(json) {
  return GetRequestToJSONTyped(json, false);
}
function GetRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "ids": value["ids"],
    "include": value["include"]
  };
}

// src/models/GetResultItemModel.ts
function GetResultItemModelFromJSON(json) {
  return GetResultItemModelFromJSONTyped(json, false);
}
function GetResultItemModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "id": json["id"],
    "metadata": json["metadata"] == null ? void 0 : json["metadata"],
    "contents": json["contents"] == null ? void 0 : json["contents"],
    "vector": json["vector"] == null ? void 0 : json["vector"]
  };
}

// src/models/GetResponseModel.ts
function GetResponseModelFromJSON(json) {
  return GetResponseModelFromJSONTyped(json, false);
}
function GetResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "results": json["results"].map(GetResultItemModelFromJSON)
  };
}

// src/models/IndexInfoResponseModel.ts
function IndexInfoResponseModelFromJSON(json) {
  return IndexInfoResponseModelFromJSONTyped(json, false);
}
function IndexInfoResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "indexName": json["index_name"],
    "indexType": json["index_type"],
    "isTrained": json["is_trained"],
    "indexConfig": json["index_config"]
  };
}

// src/models/IndexListResponseModel.ts
function IndexListResponseModelFromJSON(json) {
  return IndexListResponseModelFromJSONTyped(json, false);
}
function IndexListResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "indexes": json["indexes"]
  };
}

// src/models/IndexOperationRequest.ts
function IndexOperationRequestToJSON(json) {
  return IndexOperationRequestToJSONTyped(json, false);
}
function IndexOperationRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"]
  };
}

// src/models/IndexTrainingStatusResponseModel.ts
function IndexTrainingStatusResponseModelFromJSON(json) {
  return IndexTrainingStatusResponseModelFromJSONTyped(json, false);
}
function IndexTrainingStatusResponseModelFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "trainingIndexes": json["training_indexes"],
    "retrainThreshold": json["retrain_threshold"],
    "workerPid": json["worker_pid"],
    "globalTraining": json["global_training"]
  };
}

// src/models/ListIDsRequest.ts
function ListIDsRequestToJSON(json) {
  return ListIDsRequestToJSONTyped(json, false);
}
function ListIDsRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"]
  };
}

// src/models/ListIDsResponse.ts
function ListIDsResponseFromJSON(json) {
  return ListIDsResponseFromJSONTyped(json, false);
}
function ListIDsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "ids": json["ids"],
    "count": json["count"]
  };
}

// src/models/Results.ts
function ResultsFromJSON(json) {
  return ResultsFromJSONTyped(json, false);
}
function ResultsFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// src/models/QueryResponse.ts
function QueryResponseFromJSON(json) {
  return QueryResponseFromJSONTyped(json, false);
}
function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    "results": ResultsFromJSON(json["results"])
  };
}

// src/models/Request.ts
function RequestToJSON(json) {
  return RequestToJSONTyped(json, false);
}
function RequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "query_vectors": value["queryVectors"],
    "query_contents": value["queryContents"],
    "top_k": value["topK"],
    "n_probes": value["nProbes"],
    "greedy": value["greedy"],
    "filters": value["filters"],
    "include": value["include"]
  };
}

// src/models/TrainRequest.ts
function TrainRequestToJSON(json) {
  return TrainRequestToJSONTyped(json, false);
}
function TrainRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "n_lists": value["nLists"],
    "batch_size": value["batchSize"],
    "max_iters": value["maxIters"],
    "tolerance": value["tolerance"],
    "max_memory": value["maxMemory"]
  };
}

// src/models/VectorItem.ts
function VectorItemToJSON(json) {
  return VectorItemToJSONTyped(json, false);
}
function VectorItemToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "id": value["id"],
    "vector": value["vector"],
    "contents": ContentsToJSON(value["contents"]),
    "metadata": value["metadata"]
  };
}

// src/models/UpsertRequest.ts
function UpsertRequestToJSON(json) {
  return UpsertRequestToJSONTyped(json, false);
}
function UpsertRequestToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    "index_key": value["indexKey"],
    "index_name": value["indexName"],
    "items": value["items"].map(VectorItemToJSON)
  };
}

// src/apis/DefaultApi.ts
var DefaultApi = class extends BaseAPI {
  /**
   * Create a new encrypted index with the provided configuration.
   * Create Encrypted Index
   */
  async createIndexV1IndexesCreatePostRaw(requestParameters, initOverrides) {
    if (requestParameters["createIndexRequest"] == null) {
      throw new RequiredError(
        "createIndexRequest",
        'Required parameter "createIndexRequest" was null or undefined when calling createIndexV1IndexesCreatePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/indexes/create`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: CreateIndexRequestToJSON(requestParameters["createIndexRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Create a new encrypted index with the provided configuration.
   * Create Encrypted Index
   */
  async createIndexV1IndexesCreatePost(requestParameters, initOverrides) {
    const response = await this.createIndexV1IndexesCreatePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete a specific index.
   * Delete Encrypted Index
   */
  async deleteIndexV1IndexesDeletePostRaw(requestParameters, initOverrides) {
    if (requestParameters["indexOperationRequest"] == null) {
      throw new RequiredError(
        "indexOperationRequest",
        'Required parameter "indexOperationRequest" was null or undefined when calling deleteIndexV1IndexesDeletePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/indexes/delete`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: IndexOperationRequestToJSON(requestParameters["indexOperationRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Delete a specific index.
   * Delete Encrypted Index
   */
  async deleteIndexV1IndexesDeletePost(requestParameters, initOverrides) {
    const response = await this.deleteIndexV1IndexesDeletePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Delete vectors by their IDs.
   * Delete Items from Encrypted Index
   */
  async deleteVectorsV1VectorsDeletePostRaw(requestParameters, initOverrides) {
    if (requestParameters["deleteRequest"] == null) {
      throw new RequiredError(
        "deleteRequest",
        'Required parameter "deleteRequest" was null or undefined when calling deleteVectorsV1VectorsDeletePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/delete`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: DeleteRequestToJSON(requestParameters["deleteRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Delete vectors by their IDs.
   * Delete Items from Encrypted Index
   */
  async deleteVectorsV1VectorsDeletePost(requestParameters, initOverrides) {
    const response = await this.deleteVectorsV1VectorsDeletePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get information about a specific index.
   * Describe Encrypted Index
   */
  async getIndexInfoV1IndexesDescribePostRaw(requestParameters, initOverrides) {
    if (requestParameters["indexOperationRequest"] == null) {
      throw new RequiredError(
        "indexOperationRequest",
        'Required parameter "indexOperationRequest" was null or undefined when calling getIndexInfoV1IndexesDescribePost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/indexes/describe`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: IndexOperationRequestToJSON(requestParameters["indexOperationRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => IndexInfoResponseModelFromJSON(jsonValue));
  }
  /**
   * Get information about a specific index.
   * Describe Encrypted Index
   */
  async getIndexInfoV1IndexesDescribePost(requestParameters, initOverrides) {
    const response = await this.getIndexInfoV1IndexesDescribePostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the number of vectors stored in an index
   * Get the number of vectors in an index
   */
  async getIndexSizeV1VectorsNumVectorsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["indexOperationRequest"] == null) {
      throw new RequiredError(
        "indexOperationRequest",
        'Required parameter "indexOperationRequest" was null or undefined when calling getIndexSizeV1VectorsNumVectorsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/num_vectors`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: IndexOperationRequestToJSON(requestParameters["indexOperationRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Get the number of vectors stored in an index
   * Get the number of vectors in an index
   */
  async getIndexSizeV1VectorsNumVectorsPost(requestParameters, initOverrides) {
    const response = await this.getIndexSizeV1VectorsNumVectorsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Get the current training status including indexes being trained and the retrain threshold configuration.  Returns:     dict: Training status information including:         - training_indexes: List of index names currently being trained         - retrain_threshold: The multiplier used for the retraining threshold
   * Get Training Status
   */
  async getTrainingStatusV1IndexesTrainingStatusGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/v1/indexes/training-status`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => IndexTrainingStatusResponseModelFromJSON(jsonValue));
  }
  /**
   * Get the current training status including indexes being trained and the retrain threshold configuration.  Returns:     dict: Training status information including:         - training_indexes: List of index names currently being trained         - retrain_threshold: The multiplier used for the retraining threshold
   * Get Training Status
   */
  async getTrainingStatusV1IndexesTrainingStatusGet(initOverrides) {
    const response = await this.getTrainingStatusV1IndexesTrainingStatusGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Retrieve vectors by their IDs.
   * Get Items from Encrypted Index
   */
  async getVectorsV1VectorsGetPostRaw(requestParameters, initOverrides) {
    if (requestParameters["getRequest"] == null) {
      throw new RequiredError(
        "getRequest",
        'Required parameter "getRequest" was null or undefined when calling getVectorsV1VectorsGetPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/get`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: GetRequestToJSON(requestParameters["getRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => GetResponseModelFromJSON(jsonValue));
  }
  /**
   * Retrieve vectors by their IDs.
   * Get Items from Encrypted Index
   */
  async getVectorsV1VectorsGetPost(requestParameters, initOverrides) {
    const response = await this.getVectorsV1VectorsGetPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Check if the API is running.
   * Health check endpoint
   */
  async healthCheckV1HealthGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    const response = await this.request({
      path: `/v1/health`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response);
  }
  /**
   * Check if the API is running.
   * Health check endpoint
   */
  async healthCheckV1HealthGet(initOverrides) {
    const response = await this.healthCheckV1HealthGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * List all item IDs currently stored in the index.  Returns a list of all IDs and the total count.
   * List all IDs in an index
   */
  async listIdsV1VectorsListIdsPostRaw(requestParameters, initOverrides) {
    if (requestParameters["listIDsRequest"] == null) {
      throw new RequiredError(
        "listIDsRequest",
        'Required parameter "listIDsRequest" was null or undefined when calling listIdsV1VectorsListIdsPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/list_ids`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: ListIDsRequestToJSON(requestParameters["listIDsRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => ListIDsResponseFromJSON(jsonValue));
  }
  /**
   * List all item IDs currently stored in the index.  Returns a list of all IDs and the total count.
   * List all IDs in an index
   */
  async listIdsV1VectorsListIdsPost(requestParameters, initOverrides) {
    const response = await this.listIdsV1VectorsListIdsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * List all available indexes.
   * List Encrypted Indexes
   */
  async listIndexesV1IndexesListGetRaw(initOverrides) {
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/indexes/list`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => IndexListResponseModelFromJSON(jsonValue));
  }
  /**
   * List all available indexes.
   * List Encrypted Indexes
   */
  async listIndexesV1IndexesListGet(initOverrides) {
    const response = await this.listIndexesV1IndexesListGetRaw(initOverrides);
    return await response.value();
  }
  /**
   * Search for nearest neighbors in the index.
   * Query Encrypted Index
   */
  async queryVectorsV1VectorsQueryPostRaw(requestParameters, initOverrides) {
    if (requestParameters["request"] == null) {
      throw new RequiredError(
        "request",
        'Required parameter "request" was null or undefined when calling queryVectorsV1VectorsQueryPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/query`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: RequestToJSON(requestParameters["request"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => QueryResponseFromJSON(jsonValue));
  }
  /**
   * Search for nearest neighbors in the index.
   * Query Encrypted Index
   */
  async queryVectorsV1VectorsQueryPost(requestParameters, initOverrides) {
    const response = await this.queryVectorsV1VectorsQueryPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Train the index for efficient querying.  Note: This endpoint triggers manual training. Automatic training is also triggered based on vector count thresholds after upserts.
   * Train Encrypted index
   */
  async trainIndexV1IndexesTrainPostRaw(requestParameters, initOverrides) {
    if (requestParameters["trainRequest"] == null) {
      throw new RequiredError(
        "trainRequest",
        'Required parameter "trainRequest" was null or undefined when calling trainIndexV1IndexesTrainPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/indexes/train`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: TrainRequestToJSON(requestParameters["trainRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Train the index for efficient querying.  Note: This endpoint triggers manual training. Automatic training is also triggered based on vector count thresholds after upserts.
   * Train Encrypted index
   */
  async trainIndexV1IndexesTrainPost(requestParameters, initOverrides) {
    const response = await this.trainIndexV1IndexesTrainPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Add or update vectors in the index.  After upserting, checks if the index needs training/retraining based on the number of vectors and triggers automatic training if needed.
   * Add Items to Encrypted Index
   */
  async upsertVectorsV1VectorsUpsertPostRaw(requestParameters, initOverrides) {
    if (requestParameters["upsertRequest"] == null) {
      throw new RequiredError(
        "upsertRequest",
        'Required parameter "upsertRequest" was null or undefined when calling upsertVectorsV1VectorsUpsertPost().'
      );
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.apiKey) {
      headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key");
    }
    const response = await this.request({
      path: `/v1/vectors/upsert`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: UpsertRequestToJSON(requestParameters["upsertRequest"])
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
  }
  /**
   * Add or update vectors in the index.  After upserting, checks if the index needs training/retraining based on the number of vectors and triggers automatic training if needed.
   * Add Items to Encrypted Index
   */
  async upsertVectorsV1VectorsUpsertPost(requestParameters, initOverrides) {
    const response = await this.upsertVectorsV1VectorsUpsertPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
};

// src/types.ts
function isJsonValue(value, visited = /* @__PURE__ */ new WeakSet()) {
  if (value === null) return true;
  const type = typeof value;
  if (type === "string" || type === "number" || type === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    if (visited.has(value)) return false;
    visited.add(value);
    return value.every((item) => isJsonValue(item, visited));
  }
  if (type === "object") {
    const obj = value;
    if (visited.has(obj)) return false;
    visited.add(obj);
    return Object.values(obj).every((item) => isJsonValue(item, visited));
  }
  return false;
}
function isError(error) {
  return error instanceof Error;
}
function getErrorMessage(error) {
  if (isError(error)) {
    return error.message;
  }
  if (typeof error === "string") {
    return error;
  }
  return String(error);
}

// src/encryptedIndex.ts
var EncryptedIndex = class {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars
  constructor(indexName, indexKey, indexConfig, api, _embeddingModel) {
    this.indexName = "";
    this.indexName = indexName;
    this.indexKey = indexKey;
    this.api = api;
    const legacyConfig = indexConfig;
    const isIVFPQ = indexConfig.type?.toLowerCase() === "ivfpq";
    const normalizedConfig = {
      dimension: indexConfig.dimension,
      type: indexConfig.type,
      pqDim: 0,
      // Default values
      pqBits: 0
    };
    if (isIVFPQ) {
      normalizedConfig.pqDim = indexConfig.pqDim ?? legacyConfig.pq_dim ?? 0;
      normalizedConfig.pqBits = indexConfig.pqBits ?? legacyConfig.pq_bits ?? 0;
    }
    this.indexConfig = normalizedConfig;
  }
  handleApiError(error) {
    console.error("Full error object:", JSON.stringify(error, null, 2));
    const hasResponse = (err) => {
      return typeof err === "object" && err !== null && "response" in err;
    };
    const hasBody = (err) => {
      return typeof err === "object" && err !== null && "body" in err;
    };
    const hasMessage = (err) => {
      return typeof err === "object" && err !== null && "message" in err && typeof err.message === "string";
    };
    const hasCause = (err) => {
      return typeof err === "object" && err !== null && "cause" in err;
    };
    const hasCode = (err) => {
      return typeof err === "object" && err !== null && "code" in err;
    };
    const hasStack = (err) => {
      return typeof err === "object" && err !== null && "stack" in err;
    };
    if (hasResponse(error)) {
      console.error("HTTP Status Code:", error.response.statusCode || error.response.status);
      console.error("Response Headers:", JSON.stringify(error.response.headers, null, 2));
      console.error("Response Body:", hasBody(error) ? error.body : error.response.body || error.response.data);
    } else if (hasBody(error)) {
      console.error("Error Body:", error.body);
    } else {
      console.error("No response from server");
      if (hasMessage(error)) {
        console.error("Error message:", error.message);
      }
      if (hasCause(error)) {
        console.error("Error cause:", error.cause);
        if (typeof error.cause === "object" && error.cause !== null) {
          console.error("Cause details:", JSON.stringify(error.cause, null, 2));
        }
      }
      if (hasCode(error)) {
        console.error("Error code:", error.code);
      }
      if (hasStack(error)) {
        console.error("Error stack trace:", error.stack);
      }
    }
    let errorBody = hasBody(error) ? error.body : hasResponse(error) ? error.response.body || error.response.data : void 0;
    if (typeof errorBody === "string") {
      try {
        errorBody = JSON.parse(errorBody);
      } catch (e) {
      }
    }
    if (errorBody) {
      try {
        if (typeof errorBody === "object" && errorBody !== null && "detail" in errorBody) {
          const detailValue = errorBody.detail;
          if (Array.isArray(detailValue)) {
            const err = errorBody;
            throw new Error(`Validation failed: ${JSON.stringify(err.detail)}`);
          } else {
            const err = errorBody;
            const statusCode2 = err.statusCode || (hasResponse(error) ? error.response.statusCode || error.response.status : void 0) || "Unknown status";
            throw new Error(`${statusCode2} - ${err.detail}`);
          }
        }
      } catch (e) {
        if (isError(e) && e.message.includes("Validation failed")) {
          throw e;
        }
        throw new Error(`Unhandled error format: ${JSON.stringify(errorBody)}`);
      }
    }
    const statusCode = hasResponse(error) ? error.response.statusCode || error.response.status : "Unknown";
    let errorMessage = hasMessage(error) ? error.message : "Unknown error";
    if (hasMessage(error) && error.message === "fetch failed" && hasCause(error)) {
      const causeMsg = hasMessage(error.cause) ? error.cause.message : String(error.cause);
      errorMessage = `Network request failed: ${causeMsg}`;
    } else if (hasCode(error)) {
      errorMessage = `${errorMessage} (code: ${error.code})`;
    }
    throw new Error(`HTTP error ${statusCode}: ${errorMessage}`);
  }
  /**
   * Type guard to check if value is an object
   */
  isObject(value) {
    return typeof value === "object" && value !== null;
  }
  /**
   * Type guard to check if error has a response property
   */
  hasResponseProperty(err) {
    return this.isObject(err) && "response" in err;
  }
  /**
   * Type guard to check if response has a body property
   */
  hasBodyProperty(response) {
    return this.isObject(response) && "body" in response;
  }
  /**
   * Type guard to check if body has a detail property that is a string
   */
  hasDetailString(body) {
    return this.isObject(body) && "detail" in body && typeof body.detail === "string";
  }
  /**
   * Safely extracts error detail string from nested error structure
   * Returns the detail string if present, otherwise undefined
   */
  extractErrorDetail(err) {
    if (!this.hasResponseProperty(err)) {
      return void 0;
    }
    if (!this.hasBodyProperty(err.response)) {
      return void 0;
    }
    if (!this.hasDetailString(err.response.body)) {
      return void 0;
    }
    return err.response.body.detail;
  }
  async describeIndex(indexName, indexKey) {
    try {
      const keyHex = Buffer.from(indexKey).toString("hex");
      const request = {
        indexName,
        indexKey: keyHex
      };
      const apiResponse = await this.api.getIndexInfoV1IndexesDescribePost({ indexOperationRequest: request });
      return apiResponse;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  async getIndexName() {
    const response = await this.describeIndex(this.indexName, this.indexKey);
    return response.indexName;
  }
  async getIndexType() {
    const response = await this.describeIndex(this.indexName, this.indexKey);
    return response.indexType;
  }
  async isTrained() {
    const response = await this.describeIndex(this.indexName, this.indexKey);
    return response.isTrained;
  }
  async getIndexConfig() {
    const response = await this.describeIndex(this.indexName, this.indexKey);
    this.indexConfig = response.indexConfig;
    if (this.indexConfig.type === "ivf_flat") {
      return { ...this.indexConfig };
    } else if (this.indexConfig.type === "ivf_pq") {
      return { ...this.indexConfig };
    } else {
      return { ...this.indexConfig };
    }
  }
  /**
   * Delete an index
   * @returns Promise with the result of the operation
   */
  async deleteIndex() {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      const request = {
        indexName: this.indexName,
        indexKey: keyHex
      };
      try {
        await this.api.getIndexInfoV1IndexesDescribePost({ indexOperationRequest: request });
      } catch (infoError) {
        const errorDetail = this.extractErrorDetail(infoError);
        if (errorDetail?.includes("not exist")) {
          return { status: "success", message: `Index '${this.indexName}' was already deleted` };
        }
        throw infoError;
      }
      const response = await this.api.deleteIndexV1IndexesDeletePost({ indexOperationRequest: request });
      return response;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
     * Retrieve vectors by their IDs
     * @param ids IDs of vectors to retrieve
     * @param include Fields to include in results
     * @returns Promise with the retrieved vectors
     */
  async get({
    ids,
    include = ["vector", "contents", "metadata"]
  }) {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      const includeFields = [];
      if (include.includes("vector")) includeFields.push("vector");
      if (include.includes("contents")) includeFields.push("contents");
      if (include.includes("metadata")) includeFields.push("metadata");
      const getRequest = {
        indexName: this.indexName,
        indexKey: keyHex,
        ids,
        include: includeFields
      };
      const response = await this.api.getVectorsV1VectorsGetPost({ getRequest });
      const responseBody = response;
      const items = responseBody.results || [];
      console.log(`[DEBUG] Got ${items.length} items in response`);
      return items.map((item) => {
        const result = { id: item.id };
        if (item.vector) result.vector = item.vector;
        if (item.contents) {
          if (typeof item.contents === "string") {
            try {
              result.contents = Buffer.from(item.contents, "base64").toString("utf-8");
            } catch (e) {
              result.contents = item.contents;
            }
          } else if (item.contents instanceof Buffer) {
            result.contents = item.contents;
          } else {
            result.contents = item.contents;
          }
        }
        if (item.metadata) result.metadata = item.metadata;
        return result;
      });
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
  * Train the index for efficient querying
  * @param batchSize Size of batches for training
  * @param maxIters Maximum number of iterations
  * @param tolerance Convergence tolerance
  * @param nLists Number of Voronoi cells/clusters for IVF indexes
  * @returns Promise with the result of the operation
  */
  async train({
    nLists,
    batchSize,
    maxIters,
    tolerance
  } = {}) {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      const trainRequest = {
        indexName: this.indexName,
        indexKey: keyHex,
        batchSize: batchSize ?? void 0,
        maxIters: maxIters ?? void 0,
        tolerance: tolerance ?? void 0,
        nLists: nLists ?? void 0,
        maxMemory: void 0
      };
      const response = await this.api.trainIndexV1IndexesTrainPost({ trainRequest });
      return response;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Add or update vectors in the index
   *
   * This method accepts either items (VectorItem[]) or parallel arrays (ids + vectors)
   *
   * @param items Array of VectorItems containing id, vector, and optional metadata/contents
   * @param ids Array of ID strings for each vector (used with vectors parameter)
   * @param vectors Array of vector embeddings corresponding to each ID (used with ids parameter)
   * @returns Promise resolving to operation result with status and details
   * @throws Error with detailed validation information for invalid inputs
   */
  async upsert({
    items,
    ids,
    vectors
  }) {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      let finalItems = [];
      if (items !== void 0) {
        if (!Array.isArray(items)) {
          throw new Error("Invalid upsert call: items must be an array");
        }
        if (items.length === 0) {
          return { status: "success", message: "No items to upsert" };
        }
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (!item || typeof item !== "object") {
            throw new Error(`Invalid VectorItem at index ${i}: Item must be an object, got ${typeof item}`);
          }
          if (!item.id) {
            throw new Error(`Invalid VectorItem at index ${i}: Missing required 'id' field. Each VectorItem must have an 'id' property.`);
          }
          if (typeof item.id !== "string") {
            throw new Error(`Invalid VectorItem at index ${i}: Field 'id' must be a string, got ${typeof item.id}`);
          }
          if (!item.vector && !item.contents) {
            throw new Error(`Invalid VectorItem at index ${i} (id: "${item.id}"): Must provide either 'vector' or 'contents' field`);
          }
          if (item.vector) {
            if (!Array.isArray(item.vector)) {
              throw new Error(`Invalid VectorItem at index ${i} (id: "${item.id}"): Field 'vector' must be an array, got ${typeof item.vector}`);
            }
            if (item.vector.length === 0) {
              throw new Error(`Invalid VectorItem at index ${i} (id: "${item.id}"): Vector array cannot be empty`);
            }
            for (let j = 0; j < item.vector.length; j++) {
              if (typeof item.vector[j] !== "number" || !isFinite(item.vector[j])) {
                throw new Error(`Invalid VectorItem at index ${i} (id: "${item.id}"): Vector element at position ${j} must be a finite number, got ${typeof item.vector[j]}`);
              }
            }
          }
          if (item.metadata !== void 0 && item.metadata !== null && typeof item.metadata !== "object") {
            throw new Error(`Invalid VectorItem at index ${i} (id: "${item.id}"): Field 'metadata' must be an object or null, got ${typeof item.metadata}`);
          }
        }
        finalItems = items;
      } else if (ids !== void 0 && vectors !== void 0) {
        if (!Array.isArray(ids)) {
          throw new Error("Invalid upsert call: ids must be an array of strings");
        }
        if (!Array.isArray(vectors)) {
          throw new Error("Invalid upsert call: vectors must be an array of number arrays");
        }
        if (ids.length !== vectors.length) {
          throw new Error(`Array length mismatch: ${ids.length} IDs provided but ${vectors.length} vectors provided. The number of IDs must match the number of vectors.`);
        }
        if (ids.length === 0) {
          return { status: "success", message: "No items to upsert" };
        }
        for (let i = 0; i < ids.length; i++) {
          if (typeof ids[i] !== "string") {
            throw new Error(`Invalid ID at index ${i}: IDs must be strings, got ${typeof ids[i]}`);
          }
          if (ids[i].trim() === "") {
            throw new Error(`Invalid ID at index ${i}: IDs cannot be empty strings`);
          }
        }
        for (let i = 0; i < vectors.length; i++) {
          const vector = vectors[i];
          if (!Array.isArray(vector)) {
            throw new Error(`Invalid vector at index ${i} (id: "${ids[i]}"): Vector must be an array, got ${typeof vector}`);
          }
          if (vector.length === 0) {
            throw new Error(`Invalid vector at index ${i} (id: "${ids[i]}"): Vector array cannot be empty`);
          }
          for (let j = 0; j < vector.length; j++) {
            if (typeof vector[j] !== "number" || !isFinite(vector[j])) {
              throw new Error(`Invalid vector at index ${i} (id: "${ids[i]}"): Vector element at position ${j} must be a finite number, got ${typeof vector[j]}`);
            }
          }
        }
        finalItems = ids.map((id, index) => ({
          id: id.toString(),
          vector: vectors[index],
          contents: void 0,
          metadata: void 0
        }));
      } else {
        throw new Error("Invalid upsert call: Must provide either 'items' or both 'ids' and 'vectors'");
      }
      const processedItems = finalItems.map((item, index) => {
        let contentValue = void 0;
        if (item.contents) {
          try {
            if (typeof item.contents === "string") {
              contentValue = item.contents;
            } else {
              contentValue = Buffer.from(item.contents).toString("base64");
            }
          } catch (error) {
            throw new Error(`Failed to process contents for item at index ${index} (id: "${item.id}"): ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        return {
          id: item.id,
          vector: item.vector,
          contents: contentValue,
          metadata: item.metadata || void 0
        };
      });
      const upsertRequest = {
        indexName: this.indexName,
        indexKey: keyHex,
        items: processedItems
      };
      const response = await this.api.upsertVectorsV1VectorsUpsertPost({ upsertRequest });
      return response;
    } catch (error) {
      const hasMessage = (err) => {
        return typeof err === "object" && err !== null && "message" in err && typeof err.message === "string";
      };
      if (hasMessage(error) && !error.message.startsWith("Invalid")) {
        const enhancedMessage = `Upsert operation failed: ${error.message}`;
        const enhancedError = new Error(enhancedMessage);
        enhancedError.stack = error.stack;
        throw enhancedError;
      }
      throw error;
    }
  }
  /**
   * Search for semantically similar vectors in the index.
   * Supports single vector, batch vectors, or content-based queries.
   *
   * @param queryVectors Single vector [0.1, 0.2] or batch [[0.1, 0.2], [0.3, 0.4]]
   * @param queryContents Optional text content to embed and search (alternative to queryVectors)
   * @param topK Maximum number of results to return per query
   * @param nProbes Number of cluster centers to search
   * @param filters Metadata filters (MongoDB-style queries supported)
   * @param include Fields to include in results
   * @param greedy Use faster approximate search
   * @returns Promise resolving to QueryResponse
   * @throws Error if neither queryVectors nor queryContents provided
   */
  async query({
    queryVectors,
    queryContents,
    topK,
    nProbes,
    filters,
    include,
    greedy
  }) {
    const keyHex = Buffer.from(this.indexKey).toString("hex");
    let isSingleQuery = false;
    let vectors2D;
    if (queryVectors) {
      if (Array.isArray(queryVectors) && queryVectors.length > 0 && Array.isArray(queryVectors[0])) {
        vectors2D = queryVectors;
      } else {
        vectors2D = [queryVectors];
        isSingleQuery = true;
      }
    }
    if (!vectors2D && !queryContents) {
      throw new Error("You must provide queryVectors or queryContents.");
    }
    try {
      const requestData = {
        indexName: this.indexName,
        indexKey: keyHex,
        topK: topK ?? void 0,
        nProbes: nProbes ?? void 0,
        greedy: greedy ?? void 0,
        filters: filters ?? void 0,
        include: include ?? void 0,
        queryVectors: vectors2D ? vectors2D.map((vector) => vector.map((v) => Number(v))) : [],
        queryContents: queryContents ?? void 0
      };
      const response = await this.api.queryVectorsV1VectorsQueryPost({ request: requestData });
      if (!response) {
        throw new Error("No response received from query API");
      }
      const finalResponse = response;
      if (isSingleQuery && finalResponse.results && Array.isArray(finalResponse.results) && finalResponse.results.length === 1 && Array.isArray(finalResponse.results[0])) {
        finalResponse.results = finalResponse.results[0];
      }
      return finalResponse;
    } catch (error) {
      const hasResponse = (err) => {
        return typeof err === "object" && err !== null && "response" in err;
      };
      const hasMessage = (err) => {
        return typeof err === "object" && err !== null && "message" in err && typeof err.message === "string";
      };
      const errorData = hasResponse(error) ? error.response.data : hasMessage(error) ? error.message : "Unknown error";
      console.error("Query error:", errorData);
      this.handleApiError(error);
    }
  }
  /**
   * Delete vectors from the index
   * @param ids IDs of vectors to delete
   * @returns Promise with the result of the operation
   */
  async delete({
    ids
  }) {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      const deleteRequest = {
        indexName: this.indexName,
        indexKey: keyHex,
        ids
      };
      const response = await this.api.deleteVectorsV1VectorsDeletePost({ deleteRequest });
      return response;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * List all vector IDs in the index
   * @returns Promise with object containing array of vector IDs and count
   */
  async listIds() {
    try {
      const keyHex = Buffer.from(this.indexKey).toString("hex");
      const listIDsRequest = {
        indexName: this.indexName,
        indexKey: keyHex
      };
      const response = await this.api.listIdsV1VectorsListIdsPost({ listIDsRequest });
      const responseBody = response;
      return {
        ids: responseBody.ids,
        count: responseBody.count
      };
    } catch (error) {
      this.handleApiError(error);
    }
  }
};

// src/client.ts
var import_crypto = require("crypto");
var CyborgDB = class {
  /**
   * Create a new CyborgDB client
   * @param baseUrl Base URL of the CyborgDB service  
   * @param apiKey API key for authentication
   * @param verifySsl Optional SSL verification setting. If not provided, auto-detects based on URL
   */
  constructor({
    baseUrl,
    apiKey,
    verifySsl
  }) {
    if (baseUrl.startsWith("http://")) {
      verifySsl = false;
    }
    if (verifySsl === void 0) {
      if (baseUrl.includes("localhost") || baseUrl.includes("127.0.0.1")) {
        verifySsl = false;
        console.info("SSL verification disabled for localhost (development mode)");
      } else {
        verifySsl = true;
      }
    } else if (!verifySsl) {
      console.warn("SSL verification is disabled. Not recommended for production.");
    }
    let fetchApi;
    if (!verifySsl && typeof process !== "undefined" && process.versions && process.versions.node) {
      try {
        const https = require("https");
        const agent = new https.Agent({
          rejectUnauthorized: false
        });
        fetchApi = (url, init) => {
          return globalThis.fetch(url, { ...init, agent });
        };
        console.warn("SSL verification disabled in Node.js environment");
      } catch (e) {
        console.warn("Could not configure SSL verification - using default fetch");
      }
    }
    const config = new Configuration({
      basePath: baseUrl,
      apiKey: apiKey ? () => apiKey : void 0,
      ...fetchApi && { fetchApi },
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    });
    this.api = new DefaultApi(config);
  }
  handleApiError(error) {
    console.error("Full error object:", JSON.stringify(error, null, 2));
    const hasResponse = (err) => {
      return typeof err === "object" && err !== null && "response" in err;
    };
    const hasBody = (err) => {
      return typeof err === "object" && err !== null && "body" in err;
    };
    const hasMessage = (err) => {
      return typeof err === "object" && err !== null && "message" in err && typeof err.message === "string";
    };
    const hasCause = (err) => {
      return typeof err === "object" && err !== null && "cause" in err;
    };
    const hasCode = (err) => {
      return typeof err === "object" && err !== null && "code" in err;
    };
    if (hasResponse(error)) {
      console.error("HTTP Status Code:", error.response.statusCode || error.response.status);
      console.error("Response Headers:", JSON.stringify(error.response.headers, null, 2));
      console.error("Response Body:", hasBody(error) ? error.body : error.response.body || error.response.data);
    } else if (hasBody(error)) {
      console.error("Error Body:", error.body);
    } else {
      console.error("No response from server");
      if (hasMessage(error)) {
        console.error("Error message:", error.message);
      }
      if (hasCause(error)) {
        console.error("Error cause:", error.cause);
      }
      if (hasCode(error)) {
        console.error("Error code:", error.code);
      }
    }
    let errorBody = hasBody(error) ? error.body : hasResponse(error) ? error.response.body || error.response.data : void 0;
    if (typeof errorBody === "string") {
      try {
        errorBody = JSON.parse(errorBody);
      } catch (e) {
      }
    }
    if (errorBody) {
      try {
        if (typeof errorBody === "object" && errorBody !== null && "detail" in errorBody) {
          const detailValue = errorBody.detail;
          if (Array.isArray(detailValue)) {
            const err = errorBody;
            throw new Error(`Validation failed: ${JSON.stringify(err.detail)}`);
          } else {
            const err = errorBody;
            const statusCode2 = err.statusCode || (hasResponse(error) ? error.response.statusCode || error.response.status : void 0) || "Unknown status";
            throw new Error(`${statusCode2} - ${err.detail}`);
          }
        }
      } catch (e) {
        if (isError(e) && e.message.includes("Validation failed")) {
          throw e;
        }
        throw new Error(`Unhandled error format: ${JSON.stringify(errorBody)}`);
      }
    }
    const statusCode = hasResponse(error) ? error.response.statusCode || error.response.status : "Unknown";
    let errorMessage = hasMessage(error) ? error.message : "Unknown error";
    if (hasMessage(error) && error.message === "fetch failed" && hasCause(error)) {
      const causeMsg = hasMessage(error.cause) ? error.cause.message : String(error.cause);
      errorMessage = `Network request failed: ${causeMsg}`;
    } else if (hasCode(error)) {
      errorMessage = `${errorMessage} (code: ${error.code})`;
    }
    throw new Error(`HTTP error ${statusCode}: ${errorMessage}`);
  }
  /**
   * List all available indexes
   * @returns Promise with the list of index names
   */
  async listIndexes() {
    try {
      const response = await this.api.listIndexesV1IndexesListGet();
      return response.indexes || [];
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Create a new encrypted index
   * @param indexName Name of the index
   * @param indexKey 32-byte encryption key
   * @param indexConfig Configuration for the index (optional)
   * @param metric Distance metric for the index (optional)
   * @param embeddingModel Optional name of embedding model
   * @returns Promise with the created index
   */
  async createIndex({
    indexName,
    indexKey,
    indexConfig,
    metric,
    embeddingModel
  }) {
    try {
      const keyHex = Buffer.from(indexKey).toString("hex");
      const finalConfig = indexConfig || {
        type: "ivfflat",
        dimension: void 0
      };
      const baseConfig = {
        dimension: finalConfig.dimension || void 0,
        type: finalConfig.type || "ivfflat",
        ...metric && { metric }
      };
      const indexConfigObj = finalConfig.type === "ivfpq" ? {
        ...baseConfig,
        pqDim: finalConfig.pqDim ?? 32,
        pqBits: finalConfig.pqBits ?? 8
      } : baseConfig;
      const createRequest = {
        indexName,
        indexKey: keyHex,
        indexConfig: indexConfigObj,
        embeddingModel,
        metric
      };
      await this.api.createIndexV1IndexesCreatePost({ createIndexRequest: createRequest });
      return new EncryptedIndex(
        indexName,
        indexKey,
        createRequest.indexConfig,
        this.api,
        embeddingModel
      );
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Retrieve detailed information about an existing index
   * 
   * This is a low-level method used internally by other operations. It fetches
   * comprehensive index metadata including configuration, training status, and
   * operational parameters.
   * 
   * **Information Retrieved:**
   * - Index name and type (ivfflat, ivfpq, ivf)
   * - Current training status (trained/untrained)
   * - Index configuration (dimensions, metrics, clustering parameters)
   * - Vector count and other operational statistics
   * 
   * **Security Note:**
   * Requires the correct encryption key - invalid keys will result in authentication errors.
   * The key must be the same 32-byte key used when the index was created.
   * 
   * **Usage Examples:**
   * ```typescript
   * // Typically used internally, but can be called directly
   * const indexInfo = await client.describeIndex("my-index", indexKey);
   * console.log(`Index type: ${indexInfo.indexType}`);
   * console.log(`Is trained: ${indexInfo.isTrained}`);
   * console.log(`Dimensions: ${indexInfo.indexConfig.dimension}`);
   * ```
   * 
   * @param indexName Name of the index to describe
   * @param indexKey 32-byte encryption key used when index was created
   * @returns Promise resolving to complete index information and metadata
   * @throws Error if index doesn't exist, key is invalid, or server unreachable
   * @private Internal method - consider using loadIndex() for public access
   */
  async describeIndex(indexName, indexKey) {
    try {
      const keyHex = Buffer.from(indexKey).toString("hex");
      const request = {
        indexName,
        indexKey: keyHex
      };
      const apiResponse = await this.api.getIndexInfoV1IndexesDescribePost({ indexOperationRequest: request });
      return apiResponse;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Generate a cryptographically secure 32-byte encryption key
   * 
   * Creates a random 32-byte (256-bit) key suitable for index encryption.
   * Each key is unique and provides strong security for your vector data.
   * 
   * @returns Uint8Array containing 32 cryptographically secure random bytes
   */
  generateKey() {
    return new Uint8Array((0, import_crypto.randomBytes)(32));
  }
  /**
   * Static method to generate a cryptographically secure 32-byte encryption key
   * 
   * Creates a random 32-byte (256-bit) key suitable for index encryption.
   * Each key is unique and provides strong security for your vector data.
   * 
   * @returns Uint8Array containing 32 cryptographically secure random bytes
   */
  static generateKey() {
    return new Uint8Array((0, import_crypto.randomBytes)(32));
  }
  /**
   * Load and connect to an existing encrypted index
   * 
   * Establishes a connection to a previously created index using its name and encryption key.
   * This is the primary method for accessing existing indexes and their data.
   * 
   * @param indexName Name of the existing index to load
   * @param indexKey The exact 32-byte encryption key used when creating the index  
   * @returns Promise resolving to EncryptedIndex instance ready for vector operations
   * @throws Error if index doesn't exist, key is incorrect, or connection fails
   */
  async loadIndex({
    indexName,
    indexKey
  }) {
    try {
      const response = await this.describeIndex(indexName, indexKey);
      const indexConfig = response.indexConfig;
      const loadedIndex = new EncryptedIndex(
        response.indexName,
        // Use server-confirmed index name
        indexKey,
        // Keep original binary key for future operations
        indexConfig,
        // Configuration metadata for validation and optimization
        this.api
        // Shared API client for server communication
      );
      return loadedIndex;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Check the health of the server
   * @returns Promise with the health status
   */
  async getHealth() {
    try {
      const response = await this.api.healthCheckV1HealthGet();
      return response;
    } catch (error) {
      this.handleApiError(error);
    }
  }
  /**
   * Check if any indexes are currently being trained
   *
   * Retrieves information about which indexes are currently being trained
   * and the retrain threshold configuration.
   *
   * @returns Promise resolving to training status information including:
   *   - training_indexes: Array of index names currently being trained
   *   - retrain_threshold: The multiplier used for the retraining threshold
   */
  async isTraining() {
    try {
      const response = await this.api.getTrainingStatusV1IndexesTrainingStatusGet();
      return {
        training_indexes: response.trainingIndexes || [],
        retrain_threshold: response.retrainThreshold || 0
      };
    } catch (error) {
      this.handleApiError(error);
    }
  }
};

// src/integrations/langchain/vectorstore.ts
var import_vectorstores = require("@langchain/core/vectorstores");
var CyborgVectorStore = class _CyborgVectorStore extends import_vectorstores.VectorStore {
  _vectorstoreType() {
    return "cyborgdb";
  }
  constructor(embeddings, config) {
    super(embeddings, config);
    this.indexName = config.indexName;
    if (typeof config.indexKey === "string") {
      const base64 = config.indexKey;
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      this.indexKey = bytes;
    } else {
      this.indexKey = config.indexKey;
    }
    this.dimension = config.dimension;
    this.metric = config.metric || "cosine";
    this.client = new CyborgDB({
      baseUrl: config.baseUrl,
      apiKey: config.apiKey,
      verifySsl: config.verifySsl
    });
  }
  /**
   * Generate a secure 32-byte key for use with CyborgDB indexes.
   */
  static generateKey() {
    if (typeof window !== "undefined" && window.crypto) {
      const key = new Uint8Array(32);
      window.crypto.getRandomValues(key);
      return key;
    } else {
      try {
        const g = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {};
        const crypto = g.crypto || g.require?.("crypto");
        if (crypto && crypto.randomBytes) {
          return new Uint8Array(crypto.randomBytes(32));
        }
      } catch (e) {
      }
      const key = new Uint8Array(32);
      for (let i = 0; i < 32; i++) {
        key[i] = Math.floor(Math.random() * 256);
      }
      return key;
    }
  }
  /**
   * Generate a unique ID for documents.
   */
  generateId() {
    return `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
  }
  /**
   * Initialize or load the CyborgDB index.
   */
  async initializeIndex() {
    if (this.index) {
      return;
    }
    try {
      const existingIndexes = await this.client.listIndexes();
      const indexExists = Array.isArray(existingIndexes) ? existingIndexes.includes(this.indexName) : existingIndexes.indices?.includes(this.indexName) || false;
      if (indexExists) {
        this.index = await this.client.loadIndex({
          indexName: this.indexName,
          indexKey: this.indexKey
        });
      } else {
        if (!this.dimension) {
          const dummy = await this.embeddings.embedQuery("dimension check");
          this.dimension = Array.isArray(dummy) ? dummy.length : 0;
        }
        this.index = await this.client.createIndex({
          indexName: this.indexName,
          indexKey: this.indexKey,
          metric: this.metric
        });
      }
    } catch (error) {
      console.error("Error initializing index:", error);
      throw error;
    }
  }
  /**
   * Add texts to the vector store.
   */
  async addTexts(texts, metadatas, options) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    if (metadatas) {
      const metadataArray = Array.isArray(metadatas) ? metadatas : [metadatas];
      metadataArray.forEach((meta, idx) => {
        if (meta && typeof meta === "object" && "_content" in meta) {
          throw new Error(
            `Reserved field '_content' found in metadata at index ${idx}. This field is used internally by CyborgVectorStore to store document text. Please use a different field name for your metadata.`
          );
        }
      });
    }
    const ids = options?.ids || texts.map(() => this.generateId());
    const vectors = await this.embeddings.embedDocuments(texts);
    const items = texts.map((text, i) => {
      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas || {};
      return {
        id: ids[i],
        vector: vectors[i],
        metadata: {
          ...metadata,
          _content: text
        }
      };
    });
    await this.index.upsert({ items });
    return ids;
  }
  /**
   * Add documents to the vector store.
   */
  async addDocuments(documents, options) {
    const texts = documents.map((doc) => doc.pageContent);
    const metadatas = documents.map((doc) => doc.metadata);
    return this.addTexts(texts, metadatas, options);
  }
  /**
   * Add vectors directly to the vector store.
   */
  async addVectors(vectors, documents, options) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    documents.forEach((doc, idx) => {
      if (doc.metadata && typeof doc.metadata === "object" && "_content" in doc.metadata) {
        throw new Error(
          `Reserved field '_content' found in document metadata at index ${idx}. This field is used internally by CyborgVectorStore to store document text. Please use a different field name for your metadata.`
        );
      }
    });
    const ids = options?.ids || documents.map(() => this.generateId());
    const items = vectors.map((vector, i) => ({
      id: ids[i],
      vector,
      metadata: {
        ...documents[i].metadata,
        _content: documents[i].pageContent
      }
    }));
    await this.index.upsert({ items });
    return ids;
  }
  /**
   * Delete documents from the vector store.
   */
  async delete(params) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    if (params.ids && params.ids.length > 0) {
      await this.index.delete({ ids: params.ids });
    }
  }
  /**
   * Retrieve documents by their IDs.
   */
  async get(ids) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    const response = await this.index.get({ ids, include: ["metadata"] });
    if (!response || !Array.isArray(response) || response.length === 0) {
      return [];
    }
    return response.map((item) => {
      const metadata = { ...item.metadata || {} };
      let content = "";
      if (metadata._content !== void 0) {
        if (typeof metadata._content === "string") {
          content = metadata._content;
        } else {
          console.warn(
            `[CyborgVectorStore] Non-string value found in '_content' field for document '${item.id}'. Expected string but got ${typeof metadata._content}. This likely means the document was created using the native CyborgDB API. The content will be set to an empty string. To avoid this warning, use CyborgVectorStore methods to create documents.`
          );
        }
      }
      delete metadata._content;
      return {
        pageContent: content,
        metadata
      };
    });
  }
  /**
   * List all document IDs in the vector store.
   */
  async listIds(filter) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    if (filter) {
      console.warn("Filter parameter is not yet supported by CyborgDB listIds");
    }
    const response = await this.index.listIds();
    return Array.isArray(response) ? response : response.ids || [];
  }
  /**
   * Search for documents similar to the query.
   */
  async similaritySearch(query, k = 4, filter, _callbacks) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    const embedding = await this.embeddings.embedQuery(query);
    const results = await this.index.query({
      queryVectors: embedding,
      topK: k,
      filters: filter,
      include: ["distance", "metadata"]
    });
    if (!results || !results.results) {
      return [];
    }
    let queryResults;
    if (Array.isArray(results.results)) {
      queryResults = results.results;
    } else if (results.results && typeof results.results === "object") {
      const innerResults = results.results.results;
      queryResults = Array.isArray(innerResults) ? innerResults : [];
    } else {
      queryResults = [];
    }
    return queryResults.map((item) => {
      const metadata = { ...item.metadata || {} };
      let content = "";
      if (metadata._content !== void 0) {
        if (typeof metadata._content === "string") {
          content = metadata._content;
        } else {
          console.warn(
            `[CyborgVectorStore] Non-string value found in '_content' field for document '${item.id}'. Expected string but got ${typeof metadata._content}. This likely means the document was created using the native CyborgDB API. The content will be set to an empty string. To avoid this warning, use CyborgVectorStore methods to create documents.`
          );
        }
      }
      delete metadata._content;
      return {
        pageContent: content,
        metadata: {
          ...metadata,
          id: item.id
        }
      };
    });
  }
  /**
   * Search for documents with similarity scores.
   */
  async similaritySearchWithScore(query, k = 4, filter, _callbacks) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    const embedding = await this.embeddings.embedQuery(query);
    const results = await this.index.query({
      queryVectors: embedding,
      topK: k,
      filters: filter,
      include: ["distance", "metadata"]
    });
    if (!results || !results.results) {
      return [];
    }
    let queryResults;
    if (Array.isArray(results.results)) {
      queryResults = results.results;
    } else if (results.results && typeof results.results === "object") {
      const innerResults = results.results.results;
      queryResults = Array.isArray(innerResults) ? innerResults : [];
    } else {
      queryResults = [];
    }
    return queryResults.map((item) => {
      const metadata = { ...item.metadata || {} };
      let content = "";
      if (metadata._content !== void 0) {
        if (typeof metadata._content === "string") {
          content = metadata._content;
        } else {
          console.warn(
            `[CyborgVectorStore] Non-string value found in '_content' field for document '${item.id}'. Expected string but got ${typeof metadata._content}. This likely means the document was created using the native CyborgDB API. The content will be set to an empty string. To avoid this warning, use CyborgVectorStore methods to create documents.`
          );
        }
      }
      delete metadata._content;
      const doc = {
        pageContent: content,
        metadata: {
          ...metadata,
          id: item.id
        }
      };
      const similarity = this.normalizeScore(item.distance || 0);
      return [doc, similarity];
    });
  }
  /**
   * Search for documents similar to an embedding vector.
   */
  async similaritySearchVectorWithScore(query, k, filter) {
    await this.initializeIndex();
    if (!this.index) {
      throw new Error("Index not initialized");
    }
    const results = await this.index.query({
      queryVectors: query,
      topK: k,
      filters: filter,
      include: ["distance", "metadata"]
    });
    if (!results || !results.results) {
      return [];
    }
    let queryResults;
    if (Array.isArray(results.results)) {
      queryResults = results.results;
    } else if (results.results && typeof results.results === "object") {
      const innerResults = results.results.results;
      queryResults = Array.isArray(innerResults) ? innerResults : [];
    } else {
      queryResults = [];
    }
    return queryResults.map((item) => {
      const metadata = { ...item.metadata || {} };
      let content = "";
      if (metadata._content !== void 0) {
        if (typeof metadata._content === "string") {
          content = metadata._content;
        } else {
          console.warn(
            `[CyborgVectorStore] Non-string value found in '_content' field for document '${item.id}'. Expected string but got ${typeof metadata._content}. This likely means the document was created using the native CyborgDB API. The content will be set to an empty string. To avoid this warning, use CyborgVectorStore methods to create documents.`
          );
        }
      }
      delete metadata._content;
      const doc = {
        pageContent: content,
        metadata: {
          ...metadata,
          id: item.id
        }
      };
      const similarity = this.normalizeScore(item.distance || 0);
      return [doc, similarity];
    });
  }
  /**
   * Convert distance to similarity score [0, 1].
   */
  normalizeScore(distance) {
    if (this.metric === "cosine") {
      return Math.max(0, 1 - distance / 2);
    } else if (this.metric === "euclidean") {
      return Math.exp(-distance);
    } else if (this.metric === "squared_euclidean") {
      return Math.exp(-Math.sqrt(distance));
    } else {
      return 1 / (1 + distance);
    }
  }
  /**
   * Maximal Marginal Relevance search - balances similarity with diversity.
   * 
   * @param query - The query string
   * @param options - MMR search options including k, fetchK, lambda, and filter
   * @returns Promise of documents selected by maximal marginal relevance
   */
  async maxMarginalRelevanceSearch(query, options) {
    const { k, fetchK = k * 2, lambda = 0.5, filter } = options;
    const queryEmbedding = await this.embeddings.embedQuery(query);
    const candidates = await this.similaritySearchVectorWithScore(
      queryEmbedding,
      fetchK,
      filter
    );
    if (candidates.length === 0) {
      return [];
    }
    const candidateEmbeddings = await Promise.all(
      candidates.map(
        ([doc]) => this.embeddings.embedQuery(doc.pageContent)
      )
    );
    const selected = [];
    const selectedDocs = [];
    let bestIdx = 0;
    let bestScore = candidates[0][1];
    for (let i = 1; i < candidates.length; i++) {
      if (candidates[i][1] > bestScore) {
        bestScore = candidates[i][1];
        bestIdx = i;
      }
    }
    selected.push(bestIdx);
    selectedDocs.push(candidates[bestIdx][0]);
    while (selected.length < k && selected.length < candidates.length) {
      let bestMmrScore = -Infinity;
      let bestMmrIdx = -1;
      for (let i = 0; i < candidates.length; i++) {
        if (selected.includes(i)) continue;
        const querySimScore = candidates[i][1];
        let maxSelectedSim = 0;
        for (const selectedIdx of selected) {
          const sim = this.cosineSimilarity(
            candidateEmbeddings[i],
            candidateEmbeddings[selectedIdx]
          );
          maxSelectedSim = Math.max(maxSelectedSim, sim);
        }
        const mmrScore = lambda * querySimScore - (1 - lambda) * maxSelectedSim;
        if (mmrScore > bestMmrScore) {
          bestMmrScore = mmrScore;
          bestMmrIdx = i;
        }
      }
      if (bestMmrIdx === -1) break;
      selected.push(bestMmrIdx);
      selectedDocs.push(candidates[bestMmrIdx][0]);
    }
    return selectedDocs;
  }
  /**
   * Calculate cosine similarity between two vectors.
   */
  cosineSimilarity(a, b) {
    if (a.length !== b.length) {
      throw new Error("Vectors must have the same length");
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (normA * normB);
  }
  /**
   * Create a vector store from texts.
   */
  static async fromTexts(texts, metadatas, embeddings, config) {
    const store = new _CyborgVectorStore(embeddings, config);
    await store.addTexts(texts, metadatas);
    return store;
  }
  /**
   * Create a vector store from documents.
   */
  static async fromDocuments(docs, embeddings, config) {
    const store = new _CyborgVectorStore(embeddings, config);
    await store.addDocuments(docs);
    return store;
  }
  /**
   * Create a vector store from an existing index.
   */
  static async fromExistingIndex(embeddings, config) {
    const store = new _CyborgVectorStore(embeddings, config);
    await store.initializeIndex();
    return store;
  }
};

// src/demo.ts
async function getDemoApiKey(description) {
  const endpoint = process.env.CYBORGDB_DEMO_ENDPOINT || "https://api.cyborgdb.co/v1/api-key/manage/create-demo-key";
  const finalDescription = description ?? "Temporary demo API key";
  const payload = {
    description: finalDescription
  };
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    const apiKey = data.apiKey;
    if (!apiKey) {
      const errorMsg = "Demo API key not found in response.";
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    const expiresAt = data.expiresAt;
    if (expiresAt) {
      const expiresAtDate = new Date(expiresAt * 1e3);
      const now = /* @__PURE__ */ new Date();
      const timeLeftMs = expiresAtDate.getTime() - now.getTime();
      const seconds = Math.floor(timeLeftMs / 1e3);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      let timeLeftStr = "";
      if (days > 0) {
        timeLeftStr = `${days} day${days > 1 ? "s" : ""}, ${hours % 24} hour${hours % 24 !== 1 ? "s" : ""}`;
      } else if (hours > 0) {
        timeLeftStr = `${hours} hour${hours > 1 ? "s" : ""}, ${minutes % 60} minute${minutes % 60 !== 1 ? "s" : ""}`;
      } else if (minutes > 0) {
        timeLeftStr = `${minutes} minute${minutes > 1 ? "s" : ""}, ${seconds % 60} second${seconds % 60 !== 1 ? "s" : ""}`;
      } else {
        timeLeftStr = `${seconds} second${seconds !== 1 ? "s" : ""}`;
      }
      console.info(`Demo API key will expire in ${timeLeftStr}`);
    }
    return apiKey;
  } catch (error) {
    const errorMsg = `Failed to generate demo API key: ${error instanceof Error ? error.message : String(error)}`;
    console.error(errorMsg);
    throw new Error(errorMsg);
  }
}

// src/index.ts
var VERSION = require_package().version;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  CyborgVectorStore,
  EncryptedIndex,
  VERSION,
  getDemoApiKey,
  getErrorMessage,
  isError,
  isJsonValue
});
