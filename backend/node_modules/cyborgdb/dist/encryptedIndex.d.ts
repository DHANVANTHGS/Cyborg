import { DefaultApi } from "./apis/DefaultApi";
import { VectorItem, QueryResponse, IndexConfig, IndexIVFFlatModel, IndexIVFModel, IndexIVFPQModel } from './models';
import { UpsertResponse, DeleteResponse, TrainResponse, GetResultItem, FilterExpression } from './types';
export declare class EncryptedIndex {
    private indexName;
    private indexKey;
    private indexConfig;
    private api;
    private handleApiError;
    /**
     * Type guard to check if value is an object
     */
    private isObject;
    /**
     * Type guard to check if error has a response property
     */
    private hasResponseProperty;
    /**
     * Type guard to check if response has a body property
     */
    private hasBodyProperty;
    /**
     * Type guard to check if body has a detail property that is a string
     */
    private hasDetailString;
    /**
     * Safely extracts error detail string from nested error structure
     * Returns the detail string if present, otherwise undefined
     */
    private extractErrorDetail;
    constructor(indexName: string, indexKey: Uint8Array, indexConfig: IndexConfig, api: DefaultApi, _embeddingModel?: string);
    private describeIndex;
    getIndexName(): Promise<string>;
    getIndexType(): Promise<string | undefined>;
    isTrained(): Promise<boolean>;
    getIndexConfig(): Promise<IndexIVFFlatModel | IndexIVFModel | IndexIVFPQModel>;
    /**
     * Delete an index
     * @returns Promise with the result of the operation
     */
    deleteIndex(): Promise<import("./models").CyborgdbServiceApiSchemasIndexSuccessResponseModel>;
    /**
       * Retrieve vectors by their IDs
       * @param ids IDs of vectors to retrieve
       * @param include Fields to include in results
       * @returns Promise with the retrieved vectors
       */
    get({ ids, include }: {
        ids: string[];
        include?: string[];
    }): Promise<GetResultItem[]>;
    /**
 * Train the index for efficient querying
 * @param batchSize Size of batches for training
 * @param maxIters Maximum number of iterations
 * @param tolerance Convergence tolerance
 * @param nLists Number of Voronoi cells/clusters for IVF indexes
 * @returns Promise with the result of the operation
 */
    train({ nLists, batchSize, maxIters, tolerance }?: {
        nLists?: number;
        batchSize?: number;
        maxIters?: number;
        tolerance?: number;
    }): Promise<TrainResponse>;
    /**
     * Add or update vectors in the index
     *
     * This method accepts either items (VectorItem[]) or parallel arrays (ids + vectors)
     *
     * @param items Array of VectorItems containing id, vector, and optional metadata/contents
     * @param ids Array of ID strings for each vector (used with vectors parameter)
     * @param vectors Array of vector embeddings corresponding to each ID (used with ids parameter)
     * @returns Promise resolving to operation result with status and details
     * @throws Error with detailed validation information for invalid inputs
     */
    upsert({ items, ids, vectors }: {
        items?: VectorItem[];
        ids?: string[];
        vectors?: number[][];
    }): Promise<UpsertResponse>;
    /**
     * Search for semantically similar vectors in the index.
     * Supports single vector, batch vectors, or content-based queries.
     *
     * @param queryVectors Single vector [0.1, 0.2] or batch [[0.1, 0.2], [0.3, 0.4]]
     * @param queryContents Optional text content to embed and search (alternative to queryVectors)
     * @param topK Maximum number of results to return per query
     * @param nProbes Number of cluster centers to search
     * @param filters Metadata filters (MongoDB-style queries supported)
     * @param include Fields to include in results
     * @param greedy Use faster approximate search
     * @returns Promise resolving to QueryResponse
     * @throws Error if neither queryVectors nor queryContents provided
     */
    query({ queryVectors, queryContents, topK, nProbes, filters, include, greedy }: {
        queryVectors?: number[] | number[][];
        queryContents?: string;
        topK?: number;
        nProbes?: number;
        filters?: FilterExpression;
        include?: string[];
        greedy?: boolean;
    }): Promise<QueryResponse>;
    /**
     * Delete vectors from the index
     * @param ids IDs of vectors to delete
     * @returns Promise with the result of the operation
     */
    delete({ ids }: {
        ids: string[];
    }): Promise<DeleteResponse>;
    /**
     * List all vector IDs in the index
     * @returns Promise with object containing array of vector IDs and count
     */
    listIds(): Promise<{
        ids: string[];
        count: number;
    }>;
}
