/**
 * LangChain integration for CyborgDB JavaScript SDK.
 *
 * This module provides a LangChain VectorStore implementation for CyborgDB,
 * enabling seamless integration with LangChain applications.
 *
 * Requirements:
 *   npm install @langchain/core
 */
import { FilterExpression } from '../../types';
import { VectorStore } from "@langchain/core/vectorstores";
import type { EmbeddingsInterface } from "@langchain/core/embeddings";
import { Document, DocumentInterface } from "@langchain/core/documents";
export interface CyborgVectorStoreConfig {
    indexName: string;
    indexKey: string | Uint8Array;
    apiKey: string;
    baseUrl: string;
    embedding: EmbeddingsInterface;
    indexType?: 'ivfflat' | 'ivf' | 'ivfpq';
    indexConfigParams?: Record<string, any>;
    dimension?: number;
    metric?: 'cosine' | 'euclidean' | 'squared_euclidean';
    verifySsl?: boolean;
}
export declare class CyborgVectorStore extends VectorStore {
    FilterType: Record<string, any>;
    private client;
    private index?;
    private indexName;
    private indexKey;
    private dimension?;
    private metric;
    _vectorstoreType(): string;
    constructor(embeddings: EmbeddingsInterface, config: CyborgVectorStoreConfig);
    /**
     * Generate a secure 32-byte key for use with CyborgDB indexes.
     */
    static generateKey(): Uint8Array;
    /**
     * Generate a unique ID for documents.
     */
    private generateId;
    /**
     * Initialize or load the CyborgDB index.
     */
    private initializeIndex;
    /**
     * Add texts to the vector store.
     */
    addTexts(texts: string[], metadatas?: object[] | object, options?: {
        ids?: string[];
    }): Promise<string[]>;
    /**
     * Add documents to the vector store.
     */
    addDocuments(documents: DocumentInterface[], options?: {
        ids?: string[];
    }): Promise<string[]>;
    /**
     * Add vectors directly to the vector store.
     */
    addVectors(vectors: number[][], documents: DocumentInterface[], options?: {
        ids?: string[];
    }): Promise<string[]>;
    /**
     * Delete documents from the vector store.
     */
    delete(params: {
        ids?: string[];
    }): Promise<void>;
    /**
     * Retrieve documents by their IDs.
     */
    get(ids: string[]): Promise<Document[]>;
    /**
     * List all document IDs in the vector store.
     */
    listIds(filter?: FilterExpression): Promise<string[]>;
    /**
     * Search for documents similar to the query.
     */
    similaritySearch(query: string, k?: number, filter?: this['FilterType'], _callbacks?: any): Promise<DocumentInterface[]>;
    /**
     * Search for documents with similarity scores.
     */
    similaritySearchWithScore(query: string, k?: number, filter?: this['FilterType'], _callbacks?: any): Promise<[DocumentInterface, number][]>;
    /**
     * Search for documents similar to an embedding vector.
     */
    similaritySearchVectorWithScore(query: number[], k: number, filter?: this['FilterType']): Promise<[DocumentInterface, number][]>;
    /**
     * Convert distance to similarity score [0, 1].
     */
    private normalizeScore;
    /**
     * Maximal Marginal Relevance search - balances similarity with diversity.
     *
     * @param query - The query string
     * @param options - MMR search options including k, fetchK, lambda, and filter
     * @returns Promise of documents selected by maximal marginal relevance
     */
    maxMarginalRelevanceSearch(query: string, options: {
        k: number;
        fetchK?: number;
        lambda?: number;
        filter?: Record<string, any>;
    }): Promise<DocumentInterface[]>;
    /**
     * Calculate cosine similarity between two vectors.
     */
    private cosineSimilarity;
    /**
     * Create a vector store from texts.
     */
    static fromTexts(texts: string[], metadatas: object[] | object, embeddings: EmbeddingsInterface, config: CyborgVectorStoreConfig): Promise<CyborgVectorStore>;
    /**
     * Create a vector store from documents.
     */
    static fromDocuments(docs: DocumentInterface[], embeddings: EmbeddingsInterface, config: CyborgVectorStoreConfig): Promise<CyborgVectorStore>;
    /**
     * Create a vector store from an existing index.
     */
    static fromExistingIndex(embeddings: EmbeddingsInterface, config: CyborgVectorStoreConfig): Promise<CyborgVectorStore>;
}
