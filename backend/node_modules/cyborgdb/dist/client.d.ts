import { IndexIVFPQModel as IndexIVFPQ, IndexIVFFlatModel as IndexIVFFlat, IndexIVFModel as IndexIVF } from './models';
import { EncryptedIndex } from './encryptedIndex';
import { HealthResponse, TrainingStatus } from './types';
/**
 * CyborgDB TypeScript SDK
 * Provides an interface to interact with CyborgDB vector database service
 */
export declare class CyborgDB {
    private api;
    /**
     * Create a new CyborgDB client
     * @param baseUrl Base URL of the CyborgDB service
     * @param apiKey API key for authentication
     * @param verifySsl Optional SSL verification setting. If not provided, auto-detects based on URL
     */
    constructor({ baseUrl, apiKey, verifySsl }: {
        baseUrl: string;
        apiKey?: string;
        verifySsl?: boolean;
    });
    private handleApiError;
    /**
     * List all available indexes
     * @returns Promise with the list of index names
     */
    listIndexes(): Promise<string[]>;
    /**
     * Create a new encrypted index
     * @param indexName Name of the index
     * @param indexKey 32-byte encryption key
     * @param indexConfig Configuration for the index (optional)
     * @param metric Distance metric for the index (optional)
     * @param embeddingModel Optional name of embedding model
     * @returns Promise with the created index
     */
    createIndex({ indexName, indexKey, indexConfig, metric, embeddingModel }: {
        indexName: string;
        indexKey: Uint8Array;
        indexConfig?: IndexIVFPQ | IndexIVFFlat | IndexIVF;
        metric?: 'euclidean' | 'squared_euclidean' | 'cosine';
        embeddingModel?: string;
    }): Promise<EncryptedIndex>;
    /**
     * Retrieve detailed information about an existing index
     *
     * This is a low-level method used internally by other operations. It fetches
     * comprehensive index metadata including configuration, training status, and
     * operational parameters.
     *
     * **Information Retrieved:**
     * - Index name and type (ivfflat, ivfpq, ivf)
     * - Current training status (trained/untrained)
     * - Index configuration (dimensions, metrics, clustering parameters)
     * - Vector count and other operational statistics
     *
     * **Security Note:**
     * Requires the correct encryption key - invalid keys will result in authentication errors.
     * The key must be the same 32-byte key used when the index was created.
     *
     * **Usage Examples:**
     * ```typescript
     * // Typically used internally, but can be called directly
     * const indexInfo = await client.describeIndex("my-index", indexKey);
     * console.log(`Index type: ${indexInfo.indexType}`);
     * console.log(`Is trained: ${indexInfo.isTrained}`);
     * console.log(`Dimensions: ${indexInfo.indexConfig.dimension}`);
     * ```
     *
     * @param indexName Name of the index to describe
     * @param indexKey 32-byte encryption key used when index was created
     * @returns Promise resolving to complete index information and metadata
     * @throws Error if index doesn't exist, key is invalid, or server unreachable
     * @private Internal method - consider using loadIndex() for public access
     */
    private describeIndex;
    /**
     * Generate a cryptographically secure 32-byte encryption key
     *
     * Creates a random 32-byte (256-bit) key suitable for index encryption.
     * Each key is unique and provides strong security for your vector data.
     *
     * @returns Uint8Array containing 32 cryptographically secure random bytes
     */
    generateKey(): Uint8Array;
    /**
     * Static method to generate a cryptographically secure 32-byte encryption key
     *
     * Creates a random 32-byte (256-bit) key suitable for index encryption.
     * Each key is unique and provides strong security for your vector data.
     *
     * @returns Uint8Array containing 32 cryptographically secure random bytes
     */
    static generateKey(): Uint8Array;
    /**
     * Load and connect to an existing encrypted index
     *
     * Establishes a connection to a previously created index using its name and encryption key.
     * This is the primary method for accessing existing indexes and their data.
     *
     * @param indexName Name of the existing index to load
     * @param indexKey The exact 32-byte encryption key used when creating the index
     * @returns Promise resolving to EncryptedIndex instance ready for vector operations
     * @throws Error if index doesn't exist, key is incorrect, or connection fails
     */
    loadIndex({ indexName, indexKey }: {
        indexName: string;
        indexKey: Uint8Array;
    }): Promise<EncryptedIndex>;
    /**
     * Check the health of the server
     * @returns Promise with the health status
     */
    getHealth(): Promise<HealthResponse>;
    /**
     * Check if any indexes are currently being trained
     *
     * Retrieves information about which indexes are currently being trained
     * and the retrain threshold configuration.
     *
     * @returns Promise resolving to training status information including:
     *   - training_indexes: Array of index names currently being trained
     *   - retrain_threshold: The multiplier used for the retraining threshold
     */
    isTraining(): Promise<TrainingStatus>;
}
